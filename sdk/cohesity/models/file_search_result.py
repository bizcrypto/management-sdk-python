# coding: utf-8

"""
    Cohesity REST API

    This API provides operations for interfacing with the Cohesity Cluster. NOTE: To view the documentation on the responses, click 'Model' next to 'Example Value' and keep clicking to expand the hierarchy.

    OpenAPI spec version: 1.0
    
    Generated by: https://github.com/swagger-api/swagger-codegen.git

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

        http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
"""

from pprint import pformat
from six import iteritems
import re


class FileSearchResult(object):
    """
    NOTE: This class is auto generated by the swagger code generator program.
    Do not edit the class manually.
    """
    def __init__(self, document_type=None, file_versions=None, filename=None, is_folder=None, job_id=None, job_uid=None, registered_source_id=None, source_id=None, view_box_id=None):
        """
        FileSearchResult - a model defined in Swagger

        :param dict swaggerTypes: The key is attribute name
                                  and the value is attribute type.
        :param dict attributeMap: The key is attribute name
                                  and the value is json key in definition.
        """
        self.swagger_types = {
            'document_type': 'str',
            'file_versions': 'list[FileVersion]',
            'filename': 'str',
            'is_folder': 'bool',
            'job_id': 'int',
            'job_uid': 'FileSearchResultJobUid',
            'registered_source_id': 'int',
            'source_id': 'int',
            'view_box_id': 'int'
        }

        self.attribute_map = {
            'document_type': 'documentType',
            'file_versions': 'fileVersions',
            'filename': 'filename',
            'is_folder': 'isFolder',
            'job_id': 'jobId',
            'job_uid': 'jobUid',
            'registered_source_id': 'registeredSourceId',
            'source_id': 'sourceId',
            'view_box_id': 'viewBoxId'
        }

        self._document_type = document_type
        self._file_versions = file_versions
        self._filename = filename
        self._is_folder = is_folder
        self._job_id = job_id
        self._job_uid = job_uid
        self._registered_source_id = registered_source_id
        self._source_id = source_id
        self._view_box_id = view_box_id

    @property
    def document_type(self):
        """
        Gets the document_type of this FileSearchResult.
        Specifies the inferred document type.

        :return: The document_type of this FileSearchResult.
        :rtype: str
        """
        return self._document_type

    @document_type.setter
    def document_type(self, document_type):
        """
        Sets the document_type of this FileSearchResult.
        Specifies the inferred document type.

        :param document_type: The document_type of this FileSearchResult.
        :type: str
        """

        self._document_type = document_type

    @property
    def file_versions(self):
        """
        Gets the file_versions of this FileSearchResult.
        Specifies the different snapshot versions of a file or folder that were captured at different times.

        :return: The file_versions of this FileSearchResult.
        :rtype: list[FileVersion]
        """
        return self._file_versions

    @file_versions.setter
    def file_versions(self, file_versions):
        """
        Sets the file_versions of this FileSearchResult.
        Specifies the different snapshot versions of a file or folder that were captured at different times.

        :param file_versions: The file_versions of this FileSearchResult.
        :type: list[FileVersion]
        """

        self._file_versions = file_versions

    @property
    def filename(self):
        """
        Gets the filename of this FileSearchResult.
        Specifies the name of the found file or folder.

        :return: The filename of this FileSearchResult.
        :rtype: str
        """
        return self._filename

    @filename.setter
    def filename(self, filename):
        """
        Sets the filename of this FileSearchResult.
        Specifies the name of the found file or folder.

        :param filename: The filename of this FileSearchResult.
        :type: str
        """

        self._filename = filename

    @property
    def is_folder(self):
        """
        Gets the is_folder of this FileSearchResult.
        Specifies if the found item is a folder. If true, the found item is a folder.

        :return: The is_folder of this FileSearchResult.
        :rtype: bool
        """
        return self._is_folder

    @is_folder.setter
    def is_folder(self, is_folder):
        """
        Sets the is_folder of this FileSearchResult.
        Specifies if the found item is a folder. If true, the found item is a folder.

        :param is_folder: The is_folder of this FileSearchResult.
        :type: bool
        """

        self._is_folder = is_folder

    @property
    def job_id(self):
        """
        Gets the job_id of this FileSearchResult.
        Specifies the Job id for the Protection Job that is currently associated with object that contains the backed up file or folder. If the file or folder was backed up on current Cohesity Cluster, this field contains the id for the Job that captured the object that contains the file or folder. If the file or folder was backed up on a Primary Cluster and replicated to this Cohesity Cluster, a new Inactive Job is created, the object that contains the file or folder is now associated with new Inactive Job, and this field contains the id of the new Inactive Job.

        :return: The job_id of this FileSearchResult.
        :rtype: int
        """
        return self._job_id

    @job_id.setter
    def job_id(self, job_id):
        """
        Sets the job_id of this FileSearchResult.
        Specifies the Job id for the Protection Job that is currently associated with object that contains the backed up file or folder. If the file or folder was backed up on current Cohesity Cluster, this field contains the id for the Job that captured the object that contains the file or folder. If the file or folder was backed up on a Primary Cluster and replicated to this Cohesity Cluster, a new Inactive Job is created, the object that contains the file or folder is now associated with new Inactive Job, and this field contains the id of the new Inactive Job.

        :param job_id: The job_id of this FileSearchResult.
        :type: int
        """

        self._job_id = job_id

    @property
    def job_uid(self):
        """
        Gets the job_uid of this FileSearchResult.


        :return: The job_uid of this FileSearchResult.
        :rtype: FileSearchResultJobUid
        """
        return self._job_uid

    @job_uid.setter
    def job_uid(self, job_uid):
        """
        Sets the job_uid of this FileSearchResult.


        :param job_uid: The job_uid of this FileSearchResult.
        :type: FileSearchResultJobUid
        """

        self._job_uid = job_uid

    @property
    def registered_source_id(self):
        """
        Gets the registered_source_id of this FileSearchResult.
        Specifies the id of the top-level registered source (such as a vCenter Server) where the source object that contains the the file or folder is stored.

        :return: The registered_source_id of this FileSearchResult.
        :rtype: int
        """
        return self._registered_source_id

    @registered_source_id.setter
    def registered_source_id(self, registered_source_id):
        """
        Sets the registered_source_id of this FileSearchResult.
        Specifies the id of the top-level registered source (such as a vCenter Server) where the source object that contains the the file or folder is stored.

        :param registered_source_id: The registered_source_id of this FileSearchResult.
        :type: int
        """

        self._registered_source_id = registered_source_id

    @property
    def source_id(self):
        """
        Gets the source_id of this FileSearchResult.
        Specifies the source id of the object that contains the file or folder.

        :return: The source_id of this FileSearchResult.
        :rtype: int
        """
        return self._source_id

    @source_id.setter
    def source_id(self, source_id):
        """
        Sets the source_id of this FileSearchResult.
        Specifies the source id of the object that contains the file or folder.

        :param source_id: The source_id of this FileSearchResult.
        :type: int
        """

        self._source_id = source_id

    @property
    def view_box_id(self):
        """
        Gets the view_box_id of this FileSearchResult.
        Specifies the id of the Domain (View Box) where the source object that contains the file or folder is stored.

        :return: The view_box_id of this FileSearchResult.
        :rtype: int
        """
        return self._view_box_id

    @view_box_id.setter
    def view_box_id(self, view_box_id):
        """
        Sets the view_box_id of this FileSearchResult.
        Specifies the id of the Domain (View Box) where the source object that contains the file or folder is stored.

        :param view_box_id: The view_box_id of this FileSearchResult.
        :type: int
        """

        self._view_box_id = view_box_id

    def to_dict(self):
        """
        Returns the model properties as a dict
        """
        result = {}

        for attr, _ in iteritems(self.swagger_types):
            value = getattr(self, attr)
            if isinstance(value, list):
                result[attr] = list(map(
                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
                    value
                ))
            elif hasattr(value, "to_dict"):
                result[attr] = value.to_dict()
            elif isinstance(value, dict):
                result[attr] = dict(map(
                    lambda item: (item[0], item[1].to_dict())
                    if hasattr(item[1], "to_dict") else item,
                    value.items()
                ))
            else:
                result[attr] = value

        return result

    def to_str(self):
        """
        Returns the string representation of the model
        """
        return pformat(self.to_dict())

    def __repr__(self):
        """
        For `print` and `pprint`
        """
        return self.to_str()

    def __eq__(self, other):
        """
        Returns true if both objects are equal
        """
        return self.__dict__ == other.__dict__

    def __ne__(self, other):
        """
        Returns true if both objects are not equal
        """
        return not self == other
