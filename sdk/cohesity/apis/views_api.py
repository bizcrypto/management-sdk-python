# coding: utf-8

"""
    Cohesity REST API

    This API provides operations for interfacing with the Cohesity Cluster. NOTE: To view the documentation on the responses, click 'Model' next to 'Example Value' and keep clicking to expand the hierarchy.

    OpenAPI spec version: 1.0
    
    Generated by: https://github.com/swagger-api/swagger-codegen.git

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

        http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
"""

from __future__ import absolute_import

import sys
import os
import re

# python 2 and python 3 compatibility library
from six import iteritems

from ..configuration import Configuration
from ..api_client import ApiClient


class ViewsApi(object):
    """
    NOTE: This class is auto generated by the swagger code generator program.
    Do not edit the class manually.
    Ref: https://github.com/swagger-api/swagger-codegen
    """

    def __init__(self, api_client=None):
        config = Configuration()
        if api_client:
            self.api_client = api_client
        else:
            if not config.api_client:
                config.api_client = ApiClient()
            self.api_client = config.api_client

    def clone_directory(self, body, **kwargs):
        """
        Clone a directory of a view.
        Returns error if op fails.

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.clone_directory(body, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param CloneDirectoryParams body: Request to clone a directory. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.clone_directory_with_http_info(body, **kwargs)
        else:
            (data) = self.clone_directory_with_http_info(body, **kwargs)
            return data

    def clone_directory_with_http_info(self, body, **kwargs):
        """
        Clone a directory of a view.
        Returns error if op fails.

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.clone_directory_with_http_info(body, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param CloneDirectoryParams body: Request to clone a directory. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method clone_directory" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params) or (params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `clone_directory`")

        resource_path = '/public/views/cloneDirectory'.replace('{format}', 'json')
        path_params = {}

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'POST',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type=None,
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def clone_view(self, body, **kwargs):
        """
        Clone a View.
        Returns the cloned View.

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.clone_view(body, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param CloneViewRequest body: Request to clone a View. (required)
        :return: View
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.clone_view_with_http_info(body, **kwargs)
        else:
            (data) = self.clone_view_with_http_info(body, **kwargs)
            return data

    def clone_view_with_http_info(self, body, **kwargs):
        """
        Clone a View.
        Returns the cloned View.

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.clone_view_with_http_info(body, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param CloneViewRequest body: Request to clone a View. (required)
        :return: View
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method clone_view" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params) or (params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `clone_view`")

        resource_path = '/public/views/clone'.replace('{format}', 'json')
        path_params = {}

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'POST',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='View',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def create_view(self, body, **kwargs):
        """
        Create a View.
        Returns the created View.

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.create_view(body, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param CreateViewRequest body: Request to create a View. (required)
        :return: View
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.create_view_with_http_info(body, **kwargs)
        else:
            (data) = self.create_view_with_http_info(body, **kwargs)
            return data

    def create_view_with_http_info(self, body, **kwargs):
        """
        Create a View.
        Returns the created View.

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.create_view_with_http_info(body, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param CreateViewRequest body: Request to create a View. (required)
        :return: View
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_view" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params) or (params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `create_view`")

        resource_path = '/public/views'.replace('{format}', 'json')
        path_params = {}

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'POST',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='View',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def create_view_alias(self, body, **kwargs):
        """
        Create a View Alias. A View Alias allows a directory inside the view to be mounted without specifying the entire path.
        Returns the created View Alias.

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.create_view_alias(body, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param ViewAlias body: Request to create a View. (required)
        :return: ViewAlias
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.create_view_alias_with_http_info(body, **kwargs)
        else:
            (data) = self.create_view_alias_with_http_info(body, **kwargs)
            return data

    def create_view_alias_with_http_info(self, body, **kwargs):
        """
        Create a View Alias. A View Alias allows a directory inside the view to be mounted without specifying the entire path.
        Returns the created View Alias.

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.create_view_alias_with_http_info(body, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param ViewAlias body: Request to create a View. (required)
        :return: ViewAlias
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_view_alias" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params) or (params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `create_view_alias`")

        resource_path = '/public/viewAliases'.replace('{format}', 'json')
        path_params = {}

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'POST',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='ViewAlias',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def create_view_user_quota(self, **kwargs):
        """
        Create a new quota policy for a user in a view.
        Returns error if op fails.

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.create_view_user_quota(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param ViewUserQuotaParameters body: update user quota params.
        :return: UserQuotaAndUsage
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.create_view_user_quota_with_http_info(**kwargs)
        else:
            (data) = self.create_view_user_quota_with_http_info(**kwargs)
            return data

    def create_view_user_quota_with_http_info(self, **kwargs):
        """
        Create a new quota policy for a user in a view.
        Returns error if op fails.

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.create_view_user_quota_with_http_info(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param ViewUserQuotaParameters body: update user quota params.
        :return: UserQuotaAndUsage
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_view_user_quota" % key
                )
            params[key] = val
        del params['kwargs']

        resource_path = '/public/viewUserQuotas'.replace('{format}', 'json')
        path_params = {}

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'POST',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='UserQuotaAndUsage',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def delete_view(self, name, **kwargs):
        """
        Delete a View.
        Returns delete status upon completion.

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.delete_view(name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: Specifies the View name. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.delete_view_with_http_info(name, **kwargs)
        else:
            (data) = self.delete_view_with_http_info(name, **kwargs)
            return data

    def delete_view_with_http_info(self, name, **kwargs):
        """
        Delete a View.
        Returns delete status upon completion.

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.delete_view_with_http_info(name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: Specifies the View name. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_view" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `delete_view`")

        resource_path = '/public/views/{name}'.replace('{format}', 'json')
        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'DELETE',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type=None,
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def delete_view_alias(self, name, **kwargs):
        """
        Delete a View Alias.
        Returns delete status upon completion.

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.delete_view_alias(name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: Specifies the View Alias name. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.delete_view_alias_with_http_info(name, **kwargs)
        else:
            (data) = self.delete_view_alias_with_http_info(name, **kwargs)
            return data

    def delete_view_alias_with_http_info(self, name, **kwargs):
        """
        Delete a View Alias.
        Returns delete status upon completion.

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.delete_view_alias_with_http_info(name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: Specifies the View Alias name. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_view_alias" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `delete_view_alias`")

        resource_path = '/public/viewAliases/{name}'.replace('{format}', 'json')
        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'DELETE',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type=None,
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def delete_view_users_quota(self, **kwargs):
        """
        Delete the quota policy overrides for users in a view.
        Returns error if op fails.

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.delete_view_users_quota(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param DeleteViewUsersQuotaParameters body: update user quota params.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.delete_view_users_quota_with_http_info(**kwargs)
        else:
            (data) = self.delete_view_users_quota_with_http_info(**kwargs)
            return data

    def delete_view_users_quota_with_http_info(self, **kwargs):
        """
        Delete the quota policy overrides for users in a view.
        Returns error if op fails.

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.delete_view_users_quota_with_http_info(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param DeleteViewUsersQuotaParameters body: update user quota params.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_view_users_quota" % key
                )
            params[key] = val
        del params['kwargs']

        resource_path = '/public/viewUserQuotas'.replace('{format}', 'json')
        path_params = {}

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'DELETE',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type=None,
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def get_view_by_name(self, name, **kwargs):
        """
        List details about a single View.
        Returns the View corresponding to the specified View name.

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_view_by_name(name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: Specifies the View name. (required)
        :return: View
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_view_by_name_with_http_info(name, **kwargs)
        else:
            (data) = self.get_view_by_name_with_http_info(name, **kwargs)
            return data

    def get_view_by_name_with_http_info(self, name, **kwargs):
        """
        List details about a single View.
        Returns the View corresponding to the specified View name.

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_view_by_name_with_http_info(name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: Specifies the View name. (required)
        :return: View
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_view_by_name" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_view_by_name`")

        resource_path = '/public/views/{name}'.replace('{format}', 'json')
        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='View',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def get_view_user_quotas(self, **kwargs):
        """
        Get the quota policies, usage and summary for a view for all its users. It can also fetch the quota policies, usage and summary for a user in all his views.
        Returns error if op fails.

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_view_user_quotas(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param bool include_usage: If set to true, the logical usage info is included only for users with quota overrides. By default, it is set to false.
        :param bool exclude_users_within_alert_threshold: This field can be set only when includeUsage is set to true. By default, all the users with logical usage > 0 will be returned in the result. If this field is set to true, only the list of users who has exceeded the alert threshold will be returned.
        :param int unix_uid: If interested in a user via unix-identifier, include UnixUid. Otherwise, If valid unix-id to SID mappings are available (i.e., when mixed mode is enabled) the server will perform the necessary id mapping and return the correct usage irrespective of whether the unix id / SID is provided.
        :param bool summary_only: Specifies a flag to just return a summary. If set to true, and if ViewName is not nil, it returns the summary of users for a view. Otherwise if UserId not nil, and ViewName is nil then it fetches the summary for a user in his views.  By default, it is set to false.
        :param str cookie: Cookie should be used from previous call to list user quota overrides. It resumes (or gives the next set of values) from the result of the previous call.
        :param str view_name: Specifies the name of the input view. If given, there could be three scenarios with the viewName input parameter: It gives the user quota overrides for this view, and the user quota settings. Returns 'usersQuotaAndUsage'. If given along with the user id, it returns the quota policy for this user on this view. Returns 'usersQuotaAndUsage'. If given along with SummaryOnly as true, a user quota summary for this view would be returned. Returns 'summaryForView'. If not given, then the user id is checked.
        :param str sid: If interested in a user via smb_client, include SID. Otherwise, If valid unix-id to SID mappings are available (i.e., when mixed mode is enabled) the server will perform the necessary id mapping and return the correct usage irrespective of whether the unix id / SID is provided. The string is of following format - S-1-IdentifierAuthority-SubAuthority1-SubAuthority2-...-SubAuthorityn.
        :param int page_count: Specifies the max entries that should be returned in the result.
        :param int max_view_id: Related to fetching a particular user's quota and usage in all his views. It only pertains to the scenario where either UnixUid or Sid is specified, and ViewName is nil. Specify the maxViewId for All the views returned would have view_id's less than or equal to the given MaxViewId if it is >= 0.
        :param str output_format: OutputFormat is the Output format for the output. If it is not specified, default is json.
        :return: ViewUserQuotas
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_view_user_quotas_with_http_info(**kwargs)
        else:
            (data) = self.get_view_user_quotas_with_http_info(**kwargs)
            return data

    def get_view_user_quotas_with_http_info(self, **kwargs):
        """
        Get the quota policies, usage and summary for a view for all its users. It can also fetch the quota policies, usage and summary for a user in all his views.
        Returns error if op fails.

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_view_user_quotas_with_http_info(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param bool include_usage: If set to true, the logical usage info is included only for users with quota overrides. By default, it is set to false.
        :param bool exclude_users_within_alert_threshold: This field can be set only when includeUsage is set to true. By default, all the users with logical usage > 0 will be returned in the result. If this field is set to true, only the list of users who has exceeded the alert threshold will be returned.
        :param int unix_uid: If interested in a user via unix-identifier, include UnixUid. Otherwise, If valid unix-id to SID mappings are available (i.e., when mixed mode is enabled) the server will perform the necessary id mapping and return the correct usage irrespective of whether the unix id / SID is provided.
        :param bool summary_only: Specifies a flag to just return a summary. If set to true, and if ViewName is not nil, it returns the summary of users for a view. Otherwise if UserId not nil, and ViewName is nil then it fetches the summary for a user in his views.  By default, it is set to false.
        :param str cookie: Cookie should be used from previous call to list user quota overrides. It resumes (or gives the next set of values) from the result of the previous call.
        :param str view_name: Specifies the name of the input view. If given, there could be three scenarios with the viewName input parameter: It gives the user quota overrides for this view, and the user quota settings. Returns 'usersQuotaAndUsage'. If given along with the user id, it returns the quota policy for this user on this view. Returns 'usersQuotaAndUsage'. If given along with SummaryOnly as true, a user quota summary for this view would be returned. Returns 'summaryForView'. If not given, then the user id is checked.
        :param str sid: If interested in a user via smb_client, include SID. Otherwise, If valid unix-id to SID mappings are available (i.e., when mixed mode is enabled) the server will perform the necessary id mapping and return the correct usage irrespective of whether the unix id / SID is provided. The string is of following format - S-1-IdentifierAuthority-SubAuthority1-SubAuthority2-...-SubAuthorityn.
        :param int page_count: Specifies the max entries that should be returned in the result.
        :param int max_view_id: Related to fetching a particular user's quota and usage in all his views. It only pertains to the scenario where either UnixUid or Sid is specified, and ViewName is nil. Specify the maxViewId for All the views returned would have view_id's less than or equal to the given MaxViewId if it is >= 0.
        :param str output_format: OutputFormat is the Output format for the output. If it is not specified, default is json.
        :return: ViewUserQuotas
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['include_usage', 'exclude_users_within_alert_threshold', 'unix_uid', 'summary_only', 'cookie', 'view_name', 'sid', 'page_count', 'max_view_id', 'output_format']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_view_user_quotas" % key
                )
            params[key] = val
        del params['kwargs']

        resource_path = '/public/viewUserQuotas'.replace('{format}', 'json')
        path_params = {}

        query_params = {}
        if 'include_usage' in params:
            query_params['includeUsage'] = params['include_usage']
        if 'exclude_users_within_alert_threshold' in params:
            query_params['excludeUsersWithinAlertThreshold'] = params['exclude_users_within_alert_threshold']
        if 'unix_uid' in params:
            query_params['unixUid'] = params['unix_uid']
        if 'summary_only' in params:
            query_params['summaryOnly'] = params['summary_only']
        if 'cookie' in params:
            query_params['cookie'] = params['cookie']
        if 'view_name' in params:
            query_params['viewName'] = params['view_name']
        if 'sid' in params:
            query_params['sid'] = params['sid']
        if 'page_count' in params:
            query_params['pageCount'] = params['page_count']
        if 'max_view_id' in params:
            query_params['maxViewId'] = params['max_view_id']
        if 'output_format' in params:
            query_params['outputFormat'] = params['output_format']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='ViewUserQuotas',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def get_views(self, **kwargs):
        """
        List Views filtered by some parameters.
        If no parameters are specified, all Views on the Cohesity Cluster are returned. Specifying parameters filters the results that are returned. NOTE: If maxCount is set and the number of Views returned exceeds the maxCount, there are more Views to return. To get the next set of Views, send another request and specify the id of the last View returned in viewList from the previous response.

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_views(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param bool include_inactive: Specifies if inactive Views on this Remote Cluster (which have Snapshots copied by replication) should also be returned. Inactive Views are not counted towards the maxCount. By default, this field is set to false.
        :param list[int] job_ids: Filter by Protection Job ids. Return Views that are being protected by listed Jobs, which are specified by ids.
        :param list[str] view_box_names: Filter by a list of View Box names.
        :param bool match_partial_names: If true, the names in viewNames are matched by prefix rather than exactly matched.
        :param int max_view_id: If the number of Views to return exceeds the maxCount specified in the original request, specify the id of the last View from the viewList in the previous response to get the next set of Views.
        :param bool sort_by_logical_usage: If set to true, the list is sorted descending by logical usage.
        :param bool match_alias_names: If true, view aliases are also matched with the names in viewNames.
        :param list[str] view_names: Filter by a list of View names.
        :param list[int] view_box_ids: Filter by a list of Storage Domains (View Boxes) specified by id.
        :param int max_count: Specifies a limit on the number of Views returned.
        :return: GetViewsResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_views_with_http_info(**kwargs)
        else:
            (data) = self.get_views_with_http_info(**kwargs)
            return data

    def get_views_with_http_info(self, **kwargs):
        """
        List Views filtered by some parameters.
        If no parameters are specified, all Views on the Cohesity Cluster are returned. Specifying parameters filters the results that are returned. NOTE: If maxCount is set and the number of Views returned exceeds the maxCount, there are more Views to return. To get the next set of Views, send another request and specify the id of the last View returned in viewList from the previous response.

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_views_with_http_info(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param bool include_inactive: Specifies if inactive Views on this Remote Cluster (which have Snapshots copied by replication) should also be returned. Inactive Views are not counted towards the maxCount. By default, this field is set to false.
        :param list[int] job_ids: Filter by Protection Job ids. Return Views that are being protected by listed Jobs, which are specified by ids.
        :param list[str] view_box_names: Filter by a list of View Box names.
        :param bool match_partial_names: If true, the names in viewNames are matched by prefix rather than exactly matched.
        :param int max_view_id: If the number of Views to return exceeds the maxCount specified in the original request, specify the id of the last View from the viewList in the previous response to get the next set of Views.
        :param bool sort_by_logical_usage: If set to true, the list is sorted descending by logical usage.
        :param bool match_alias_names: If true, view aliases are also matched with the names in viewNames.
        :param list[str] view_names: Filter by a list of View names.
        :param list[int] view_box_ids: Filter by a list of Storage Domains (View Boxes) specified by id.
        :param int max_count: Specifies a limit on the number of Views returned.
        :return: GetViewsResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['include_inactive', 'job_ids', 'view_box_names', 'match_partial_names', 'max_view_id', 'sort_by_logical_usage', 'match_alias_names', 'view_names', 'view_box_ids', 'max_count']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_views" % key
                )
            params[key] = val
        del params['kwargs']

        resource_path = '/public/views'.replace('{format}', 'json')
        path_params = {}

        query_params = {}
        if 'include_inactive' in params:
            query_params['includeInactive'] = params['include_inactive']
        if 'job_ids' in params:
            query_params['jobIds'] = params['job_ids']
        if 'view_box_names' in params:
            query_params['viewBoxNames'] = params['view_box_names']
        if 'match_partial_names' in params:
            query_params['matchPartialNames'] = params['match_partial_names']
        if 'max_view_id' in params:
            query_params['maxViewId'] = params['max_view_id']
        if 'sort_by_logical_usage' in params:
            query_params['SortByLogicalUsage'] = params['sort_by_logical_usage']
        if 'match_alias_names' in params:
            query_params['matchAliasNames'] = params['match_alias_names']
        if 'view_names' in params:
            query_params['viewNames'] = params['view_names']
        if 'view_box_ids' in params:
            query_params['viewBoxIds'] = params['view_box_ids']
        if 'max_count' in params:
            query_params['maxCount'] = params['max_count']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='GetViewsResult',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def get_views_by_share_name(self, **kwargs):
        """
        List shares filtered by name.
        If no parameters are specified, all shares on the Cohesity Cluster are returned. Specifying share name/prefix filters the results that are returned. NOTE: If maxCount is set and the number of Views returned exceeds the maxCount, there are more Views to return. To get the next set of Views, send another request and specify the pagination cookie from the previous response.

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_views_by_share_name(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str share_name: The share name(substring) that needs to be searched against existing views and aliases.
        :param int max_count: Specifies a limit on the number of Views returned.
        :param str pagination_cookie: Expected to be empty in the first call to GetViewsByShareName. To get the next set of results, set this value to the pagination cookie value returned  in the response of the previous call.
        :return: GetViewsByShareNameResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_views_by_share_name_with_http_info(**kwargs)
        else:
            (data) = self.get_views_by_share_name_with_http_info(**kwargs)
            return data

    def get_views_by_share_name_with_http_info(self, **kwargs):
        """
        List shares filtered by name.
        If no parameters are specified, all shares on the Cohesity Cluster are returned. Specifying share name/prefix filters the results that are returned. NOTE: If maxCount is set and the number of Views returned exceeds the maxCount, there are more Views to return. To get the next set of Views, send another request and specify the pagination cookie from the previous response.

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_views_by_share_name_with_http_info(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str share_name: The share name(substring) that needs to be searched against existing views and aliases.
        :param int max_count: Specifies a limit on the number of Views returned.
        :param str pagination_cookie: Expected to be empty in the first call to GetViewsByShareName. To get the next set of results, set this value to the pagination cookie value returned  in the response of the previous call.
        :return: GetViewsByShareNameResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['share_name', 'max_count', 'pagination_cookie']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_views_by_share_name" % key
                )
            params[key] = val
        del params['kwargs']

        resource_path = '/public/shares'.replace('{format}', 'json')
        path_params = {}

        query_params = {}
        if 'share_name' in params:
            query_params['shareName'] = params['share_name']
        if 'max_count' in params:
            query_params['maxCount'] = params['max_count']
        if 'pagination_cookie' in params:
            query_params['paginationCookie'] = params['pagination_cookie']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='GetViewsByShareNameResult',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def overwrite_view(self, body, **kwargs):
        """
        Overwrites a Target view with contents of a Source view.
        Specifies source and target view names as params. Returns the modified Target View.

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.overwrite_view(body, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param OverwriteViewParam body: Request to overwrite a Target view with contents of a Source view. (required)
        :return: View
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.overwrite_view_with_http_info(body, **kwargs)
        else:
            (data) = self.overwrite_view_with_http_info(body, **kwargs)
            return data

    def overwrite_view_with_http_info(self, body, **kwargs):
        """
        Overwrites a Target view with contents of a Source view.
        Specifies source and target view names as params. Returns the modified Target View.

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.overwrite_view_with_http_info(body, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param OverwriteViewParam body: Request to overwrite a Target view with contents of a Source view. (required)
        :return: View
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method overwrite_view" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params) or (params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `overwrite_view`")

        resource_path = '/public/views/overwrite'.replace('{format}', 'json')
        path_params = {}

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'POST',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='View',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def rename_view(self, body, name, **kwargs):
        """
        Rename a View.
        Specify original name of the View in the 'name' parameter. Returns the renamed View.

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.rename_view(body, name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param RenameViewParam body: Request to rename a View. (required)
        :param str name: Specifies the View name. (required)
        :return: View
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.rename_view_with_http_info(body, name, **kwargs)
        else:
            (data) = self.rename_view_with_http_info(body, name, **kwargs)
            return data

    def rename_view_with_http_info(self, body, name, **kwargs):
        """
        Rename a View.
        Specify original name of the View in the 'name' parameter. Returns the renamed View.

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.rename_view_with_http_info(body, name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param RenameViewParam body: Request to rename a View. (required)
        :param str name: Specifies the View name. (required)
        :return: View
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'name']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method rename_view" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params) or (params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `rename_view`")
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `rename_view`")

        resource_path = '/public/views/rename/{name}'.replace('{format}', 'json')
        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'POST',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='View',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def update_user_quota_settings(self, **kwargs):
        """
        Update the user quota settings in a view.
        Returns error if op fails.

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.update_user_quota_settings(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param UpdateUserQuotaSettingsForView body: update user quota metadata params.
        :return: UserQuotaSettings
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.update_user_quota_settings_with_http_info(**kwargs)
        else:
            (data) = self.update_user_quota_settings_with_http_info(**kwargs)
            return data

    def update_user_quota_settings_with_http_info(self, **kwargs):
        """
        Update the user quota settings in a view.
        Returns error if op fails.

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.update_user_quota_settings_with_http_info(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param UpdateUserQuotaSettingsForView body: update user quota metadata params.
        :return: UserQuotaSettings
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_user_quota_settings" % key
                )
            params[key] = val
        del params['kwargs']

        resource_path = '/public/viewUserQuotasSettings'.replace('{format}', 'json')
        path_params = {}

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'PUT',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='UserQuotaSettings',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def update_view(self, name, body, **kwargs):
        """
        Update a View.
        Returns the updated View.

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.update_view(name, body, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: Specifies the View name. (required)
        :param UpdateViewParam body: Request to update a view. (required)
        :return: View
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.update_view_with_http_info(name, body, **kwargs)
        else:
            (data) = self.update_view_with_http_info(name, body, **kwargs)
            return data

    def update_view_with_http_info(self, name, body, **kwargs):
        """
        Update a View.
        Returns the updated View.

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.update_view_with_http_info(name, body, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: Specifies the View name. (required)
        :param UpdateViewParam body: Request to update a view. (required)
        :return: View
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'body']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_view" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `update_view`")
        # verify the required parameter 'body' is set
        if ('body' not in params) or (params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `update_view`")

        resource_path = '/public/views/{name}'.replace('{format}', 'json')
        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'PUT',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='View',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def update_view_user_quota(self, **kwargs):
        """
        Update a new quota policy for a user in a view.
        Returns error if op fails.

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.update_view_user_quota(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param ViewUserQuotaParameters body: update user quota params.
        :return: UserQuotaAndUsage
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.update_view_user_quota_with_http_info(**kwargs)
        else:
            (data) = self.update_view_user_quota_with_http_info(**kwargs)
            return data

    def update_view_user_quota_with_http_info(self, **kwargs):
        """
        Update a new quota policy for a user in a view.
        Returns error if op fails.

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.update_view_user_quota_with_http_info(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param ViewUserQuotaParameters body: update user quota params.
        :return: UserQuotaAndUsage
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_view_user_quota" % key
                )
            params[key] = val
        del params['kwargs']

        resource_path = '/public/viewUserQuotas'.replace('{format}', 'json')
        path_params = {}

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'PUT',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='UserQuotaAndUsage',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))
